module Data.Algebra.Free
    ( -- * Algebra type
      AlgebraType
      -- * FreeAlgebra class
    , FreeAlgebra (..)
      -- * Combinators
    , foldFree
    , natFree
    , fmapFree
    , joinFree
    , bindFree
    )
    where

import           Prelude

import           Data.Kind (Constraint, Type)
import           Data.List.NonEmpty (NonEmpty (..))
import           Data.Monoid (Monoid (..))
import           Data.Semigroup (Semigroup, (<>))

type family AlgebraType (a :: k) (b :: l) :: Constraint

class FreeAlgebra (m :: Type -> Type)  where
    -- | Injective map that embeds generators @a@ into @m@.
    returnFree :: a -> m a
    -- | The freeness property.
    foldMapFree
        :: forall d a
         .  AlgebraType m d
        => (a -> d)   -- ^ map generators of @m@ into @d@
        -> (m a -> d) -- ^ returns a homomorphism from @m@ to @d@

type instance AlgebraType NonEmpty m = Semigroup m
instance FreeAlgebra NonEmpty where
    returnFree a = a :| []
    -- @'foldMap'@ requires @'Monoid' d@ constraint which we don't need to
    -- satisfy here
    foldMapFree f (a :| []) = f a
    foldMapFree f (a :| (b : bs)) = f a <> foldMapFree f (b :| bs)

type instance AlgebraType [] m = Monoid m
instance FreeAlgebra [] where
    returnFree a = [a]
    foldMapFree = foldMap

-- |
-- All types which satisfy @'FreeAlgebra'@ constraint are foldable.  You can
-- use this map to build a @'Foldable'@ instance.
foldFree
    :: ( FreeAlgebra m
       , AlgebraType m a
       )
    => m a
    -> a
foldFree = foldMapFree id

-- |
-- The canonical quotient map from a free algebra of a wider class to a free
-- algebra of a narrower class, e.g. from a free non-associative semigroup to
-- free associative semigroup, from a free monoid to free commutative monoid,
-- etc.
--
-- prop> natFree . natFree == natFree
-- prop> fmapFree f . natFree == hoistFree . fmapFree f
--
-- the constraints:
-- * the algebra @n a@ is of the same type as algebra @m@ (this is
--    always true, just ghc cannot prove it here)
-- * @m@ is a free algebra generated by @a@
-- * @n@ is a free algebra generated by @a@
natFree :: forall m n a .
           ( AlgebraType m (n a)
           , FreeAlgebra m
           , FreeAlgebra n
           )
        => m a
        -> n a
natFree = foldMapFree returnFree

-- |
-- All types which satisfy @'FreeAlgebra'@ constraint are functors.
-- The constraint @'AlgebraType' m (m b)@ is always satisfied.
fmapFree :: forall m a b .
            ( FreeAlgebra m
            , AlgebraType m (m b)
            )
         => (a -> b)
         -> m a
         -> m b
fmapFree f ma = foldMapFree (returnFree . f) ma

-- |
-- @'FreeAlgebra'@ constraint imply monad.
joinFree :: ( FreeAlgebra m
            , AlgebraType m (m a)
            )
         => m (m a)
         -> m a
joinFree = foldFree

-- |
-- The monadic @'bind'@ operator.  You can use @'returnF'
bindFree :: ( FreeAlgebra m
            , AlgebraType m (m b)
            , AlgebraType m (m (m b))
            )
         => m a
         -> (a -> m b)
         -> m b
bindFree ma f = joinFree $ fmapFree f ma
