module Algebra.Free.Class
    ( -- * Algebra type
      AlgebraType
      -- * FreeAlgebra class
    , FreeAlgebra (..)
      -- * Combinators
    , foldF
    , natF
    , fmapF
    , joinF
    , bindF
    )
    where

import           Prelude

import           Data.Kind (Constraint, Type)
import           Data.List.NonEmpty (NonEmpty (..))
import           Data.Monoid (Monoid (..))
import           Data.Semigroup (Semigroup, (<>))

type family AlgebraType (a :: k) (b :: l) :: Constraint

class FreeAlgebra (m :: Type -> Type)  where
    -- | Injective map that embeds generators @a@ into @m@.
    returnF :: a -> m a
    -- | The freeness property.
    foldMapF
        :: forall d a
         .  AlgebraType m d
        => (a -> d)   -- ^ map generators of @m@ into @d@
        -> (m a -> d) -- ^ returns a homomorphism from @m@ to @d@

type instance AlgebraType NonEmpty m = Semigroup m
instance FreeAlgebra NonEmpty where
    returnF a = a :| []
    -- @'foldMap'@ requires @'Monoid' d@ constraint which we don't need to
    -- satisfy here
    foldMapF f (a :| []) = f a
    foldMapF f (a :| (b : bs)) = f a <> foldMapF f (b :| bs)

type instance AlgebraType [] m = Monoid m
instance FreeAlgebra [] where
    returnF a = [a]
    foldMapF = foldMap

-- |
-- All types which satisfy @'FreeAlgebra'@ constraint are foldable.  You can
-- use this map to build a @'Foldable'@ instance.
foldF
    :: ( FreeAlgebra m
       , AlgebraType m a
       )
    => m a
    -> a
foldF = foldMapF id

-- |
-- The canonical quotient map from a free algebra of a wider class to a free
-- algebra of a narrower class, e.g. from a free non-associative semigroup to
-- free associative semigroup, from a free monoid to free commutative monoid, etc.
--
-- prop> natF . natF == natF
-- prop> fmapF f . natF == hiostF . fmapF f
--
-- the constraints:
-- * the algebra @n a@ is of the same type as algebra @m@ (this is
--    always true, just ghc cannot prove it here)
-- * @m@ is a free algebra generated by @a@
-- * @n@ is a free algebra generated by @a@
natF :: forall m n a .
          ( AlgebraType m (n a)
          , FreeAlgebra m
          , FreeAlgebra n
          )
       => m a
       -> n a
natF = foldMapF returnF

-- |
-- All types which satisfy @'FreeAlgebra'@ constraint are functors.
-- The constraint @'AlgebraType' m (m b)@ is always satisfied.
fmapF :: forall m a b .
        ( FreeAlgebra m
        , AlgebraType m (m b)
        )
     => (a -> b)
     -> m a
     -> m b
fmapF f ma = foldMapF (returnF . f) ma

-- |
-- @'FreeAlgebra'@ constraint imply monad.
joinF :: ( FreeAlgebra m
         , AlgebraType m (m a)
         )
      => m (m a)
      -> m a
joinF = foldF

-- |
-- The monadic @'bind'@ operator.  You can use @'returnF'
bindF :: ( FreeAlgebra m
         , AlgebraType m (m b)
         , AlgebraType m (m (m b))
         )
      => m a
      -> (a -> m b)
      -> m b
bindF ma f = joinF $ fmapF f ma
